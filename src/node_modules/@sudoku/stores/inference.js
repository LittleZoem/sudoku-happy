import { writable, get } from 'svelte/store';
import { hintHighLight } from '../strategy/hint_high_light';
import { candidates, inferenceKeys } from '@sudoku/stores/candidates';
import { grid, userGrid } from '@sudoku/stores/grid';
import { BOX_SIZE, SUDOKU_SIZE } from '@sudoku/constants';
import { strategyManager } from '@sudoku/strategy/strategy_manager';
import { hints } from '@sudoku/stores/hints';


function createInferenceGrid() {
	const candidateGrid = writable([
		[[], [], [], [], [], [], [], [], []],
		[[], [], [], [], [], [], [], [], []],
		[[], [], [], [], [], [], [], [], []],
		[[], [], [], [], [], [], [], [], []],
		[[], [], [], [], [], [], [], [], []],
		[[], [], [], [], [], [], [], [], []],
		[[], [], [], [], [], [], [], [], []],
		[[], [], [], [], [], [], [], [], []],
		[[], [], [], [], [], [], [], [], []],
    ]);

    const cellTrack = writable(null);
    const strategyUnits = writable(null);

    const clearCandidateGrid = () => {
        candidateGrid.set(Array.from({ length: 9 }, () => Array.from({ length: 9 }, () => [])));
    }

    const mergeUserGrid = (usrGrid) => {
        for (let y = 0; y < SUDOKU_SIZE; y++) {
            for (let x = 0; x < SUDOKU_SIZE; x++) {
                candidateGrid.update($candidateGrid => {
                    if (usrGrid[y][x] != 0) {
                        $candidateGrid[y][x].push(usrGrid[y][x]);
                    }
                    return $candidateGrid;
                })
            }
        }
    }

    const setResult = (inferenceGrid, newCellTrack, newStrategyUnits) => {
        candidateGrid.set(JSON.parse(JSON.stringify(inferenceGrid)));
        cellTrack.set(newCellTrack);
        strategyUnits.set(newStrategyUnits);
    };

    const noAnswer = () => {
        for (let y = 0; y < SUDOKU_SIZE; y++) {
            for (let x = 0; x < SUDOKU_SIZE; x++) {
                if (get(userGrid)[y][x] === 0 && get(candidateGrid)[y][x].length === 1) {
                    return false;
                }
            }
        }
        return true;
    };

    const needUpdate = (pos, value) => {
        if (get(candidateGrid)[pos.y][pos.x].length === 1
            && get(candidateGrid)[pos.y][pos.x][0] === value
            && (get(hints) === 0 || !noAnswer())) {
            return false;
        }

        return true;
    };

    const execute = () => {
        clearCandidateGrid();

        if (get(hints) > 0) {
            strategyManager.run(get(userGrid));
            setResult(strategyManager.getInferenceGrid(), strategyManager.getCellTrack(), strategyManager.getStrategyUnits());
        }
        mergeUserGrid(get(userGrid));
    };

    // userGrid.subscribe($userGrid => {
    //     clearCandidateGrid();

    //     if (get(hints) > 0) {
    //         strategyManager.run($userGrid);
    //         setResult(strategyManager.getInferenceGrid(), strategyManager.getCellTrack(), strategyManager.getStrategyUnits());
    //     }
    //     mergeUserGrid($userGrid);
    // })

    grid.subscribe($grid => {
        clearCandidateGrid();
        mergeUserGrid($grid);
    })

    hints.subscribe($hintsLevel => {
        if ($hintsLevel === 1) {
            strategyManager.run(get(userGrid));
            setResult(strategyManager.getInferenceGrid(), strategyManager.getCellTrack(), strategyManager.getStrategyUnits());
            mergeUserGrid(get(userGrid));
        } else if ($hintsLevel === 0) {
            clearCandidateGrid();
            mergeUserGrid(get(userGrid));
            cellTrack.set(null);
            strategyUnits.set(null);
        }
    })

	return {
		subscribe: candidateGrid.subscribe,

        // set: setResult,
        set: (pos, value) => {
            userGrid.set(pos, value);
            if (needUpdate(pos, value)) {
                execute();
            }
        },

        execute: execute,

        showInferece: (x, y) => {
            console.log("---------show inference---------");
            let len = get(cellTrack)[y][x].length;

            let units = get(cellTrack)[y][x];

            let strategyLink = "";

            if (len === 0) {
                strategyLink = "Possible Number";
            }
            else {

                for (let i = 0; i < len; i++) {
                    let strategyUnit = get(strategyUnits)[units[i]];
                    if (i === len - 1 ) {
                        strategyLink += strategyUnit.name();
                    }
                    else {
                        strategyLink += strategyUnit.name() + ' -> ';
                    }

                    let cells = strategyUnit.getCells();

                    // hintHighLight.add(x, y);
                    for (let j = 0; j < cells.length; j++) {
                        hintHighLight.add(cells[j].x, cells[j].y);
                        for (let k = 0; k < cells[j].highLightValues.length; k++) {
                            inferenceKeys.add(cells[j].y, cells[j].x, cells[j].highLightValues[k]);
                        }
                        candidates.setList(cells[j].y, cells[j].x, getPosCandidates(cells[j].y, cells[j].x, get(userGrid)));
                    }
                }
            }
        },
	};
}

export const inferenceGrid = createInferenceGrid();

function getPosCandidates(y, x, grid) {
    const candidates = new Set(Array.from({ length: SUDOKU_SIZE }, (_, i) => i + 1)); // 初始化候选值为 1~9

    // 如果当前位置已经有值，返回空数组（无候选值）
    if (grid[y][x] !== 0) {
        return [];
    }

    // 1. 检查当前行
    for (let i = 0; i < SUDOKU_SIZE; i++) {
        candidates.delete(grid[y][i]); // 删除当前行中的数字
    }

    // 2. 检查当前列
    for (let i = 0; i < SUDOKU_SIZE; i++) {
        candidates.delete(grid[i][x]); // 删除当前列中的数字
    }

    // 3. 检查当前 3×3 宫格
    const boxStartRow = Math.floor(y / BOX_SIZE) * BOX_SIZE; // 宫格起始行
    const boxStartCol = Math.floor(x / BOX_SIZE) * BOX_SIZE; // 宫格起始列

    for (let i = 0; i < BOX_SIZE; i++) {
        for (let j = 0; j < BOX_SIZE; j++) {
            candidates.delete(grid[boxStartRow + i][boxStartCol + j]); // 删除 3×3 宫格中的数字
        }
    }

    // 将剩余候选值转为数组并返回
    return Array.from(candidates);
}
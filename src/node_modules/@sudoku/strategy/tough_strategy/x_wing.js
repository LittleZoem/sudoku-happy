import { StrategyCell, StrategyUnit, StrategyOperator, Strategy } from '../strategy_base';

import BoxScanner from '../utils';

import { StrongLinkOperator } from '../operator/StrongLinkOp';


class XWStrategy extends Strategy
{
    constructor() {
        super("X-Wings", new StrongLinkOperator(), [true, true, false]);

        this.rowlinks = [ [], [], [], [], [], [], [], [], [] ];
        this.collinks = [ [], [], [], [], [], [], [], [], [] ];
    }

    init() {
        this.rowlinks = [ [], [], [], [], [], [], [], [], [] ];
        this.collinks = [ [], [], [], [], [], [], [], [], [] ];
    }

    /*
        midData: 每个元素： [number y1 x1 y2 x2]
    */
    load(midData) {
        let len = midData.length;

        for (let i = 0; i < len; i++) {
            if ( this.linkMatch(midData[1], midData[2], midData[3], midData[4]) === 1) {
                this.rowlinks[ midData[i][0] - 1 ].push([ midData[i][1], midData[i][2], midData[i][3], midData[i][4] ]);
            }
            else {
                this.collinks[ midData[i][0] - 1 ].push([ midData[i][1], midData[i][2], midData[i][3], midData[i][4] ]);
            }
        }
    }

    handle (candidates, cellTrack, strategyUnits) {

        let x_wing_used = false;

        const candidates_handle = (y, x, link1, link2, val) => {

            if (candidates[y][x].length !== 0 && this.misMatch(y, x, link1[0], link1[1]) && this.misMatch(y, x, link1[2], link1[3]) &&
            this.misMatch(y, x, link2[0], link2[1]) && this.misMatch(y, x, link2[2], link2[3])) {

                let index = candidates[y][x].indexOf(val);
    
                //判断对子是否会作用于该单元格
                if (index > -1) {

                    //记录策略对该单元格的影响
                    cellTrack[y][x].push(strategyUnits.length - 1);
    
                    x_wing_used = true;

                    candidates[y][x].splice(index, 1);
                }
            }
        }

        //检查行匹配
        for (let i = 0; i < 9; i++) {
            let len = this.rowlinks[i].length;
            let links = this.rowlinks[i];

            if (len >= 2) {
                for (let j = 0; j < len - 1; j++) {
                    for (let k = j + 1; k < len; k++) {
                        if ( links[j][1] === links[k][1] && links[j][3] === links[k][3]) {
                            let unit = new StrategyUnit(this.name());
    
                            unit.addCell(links[j][0], links[j][1], [i + 1]);
                            unit.addCell(links[j][2], links[j][3], [i + 1]);

                            unit.addCell(links[k][0], links[k][1], [i + 1]);
                            unit.addCell(links[k][2], links[k][3], [i + 1]);

                            strategyUnits.push(unit);

                            for (let a = 0; a < 9; a++) {
                                candidates_handle( a, links[j][1], links[j], links[k], i+1 );
                                candidates_handle( a, links[j][3], links[j], links[k], i+1 );
                            }
                        }
                    }
                }
            }
        }

        //检查列匹配
        for (let i = 0; i < 9; i++) {
            let len = this.collinks[i].length;
            let links = this.collinks[i];

            if (len >= 2) {
                for (let j = 0; j < len; j++) {
                    for (let k = j + 1; k < len; k++) {
                        if ( links[j][0] === links[k][0] && links[j][2] === links[k][2]) {
                            let unit = new StrategyUnit(this.name());
    
                            unit.addCell(links[j][0], links[j][1], [i + 1]);
                            unit.addCell(links[j][2], links[j][3], [i + 1]);

                            unit.addCell(links[k][0], links[k][1], [i + 1]);
                            unit.addCell(links[k][2], links[k][3], [i + 1]);

                            strategyUnits.push(unit);

                            for (let a = 0; a < 9; a++) {
                                candidates_handle( links[j][0], a, links[j], links[k], i+1 );
                                candidates_handle( links[j][2], a, links[j], links[k], i+1 );
                            }
                        }
                    }
                }
            }
        }

        return x_wing_used;
    }

    /*
        return : 1:行
                 2:列
    */
    linkMatch(y1, x1, y2, x2) {
        if ( y1 === y2 ) {
            return 1;
        }
        return 2;
    }

    misMatch(y1, x1, y2, x2) {
        return y1 !== y2 || x1 !== x2;
    }
}

export {
    XWStrategy
};
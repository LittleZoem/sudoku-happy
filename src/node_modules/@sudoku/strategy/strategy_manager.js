import BoxScanner, { getBox } from './utils';
import { StrategyCell, StrategyUnit } from './strategy_base';
import { NPStrategy } from './sample_strategy/naked_pairs';
import { HSStrategy } from './sample_strategy/hidden_singles';
import { XWStrategy } from '../strategy/tough_strategy/x_wing';

class StrategyManeger
{
    /*
        grid : 当前棋盘的值
    */
    constructor() {

        // 得到的提示答案
        this.hint = null;

        // 所有单元格的候选值
        this.candidates = null;

        // 单元格候选值消除跟踪  StrategyUnit id数组
        this.cellTrack = null;

        //策略找到的各个匹配
        this.strategyUnits = null;

        //策略执行顺序
        this.strategyRank = ['HS', 'NP', "XW"];

        // 策略注册
        this.strategy = {

            //简单策略
            'HS' : new HSStrategy(),
            'NP' : new NPStrategy(),
            'XW' : new XWStrategy(),

            //困难策略
        };
    }

    /*
        @param grid 棋盘数据

        迭代执行各个策略得到答案
    */
    run(grid) {

        //初始化数据
        this.init(grid);

        //找到答案的标志
        let end = false;

        while (!end) {

            end = this.checkOnlyOne();
            if (end) {
                break;
            }

            // 有策略成功执行的标志，执行成功则为true
            let flag = false;

            for (let i = 0; i < this.strategyRank.length; i++) {
                let key = this.strategyRank[i];
                flag = this.strategy[key].run(this.candidates, this.cellTrack, this.strategyUnits);
                // 一旦有策略执行成功（能缩小候选值范围），则不继续执行
                if (flag) {
                    break;
                }
            }

            if (!flag) {
                break;
            }
        }
    }

    /*
        @return 是否得到答案
        检查所有候选值，找到只有唯一解的单元格，得到输出
    */
    checkOnlyOne () {
        for (let y = 0; y < 9; y++) {
            for (let x = 0; x < 9; x++) {
                if (this.candidates[y][x].length == 1) {
                    this.hint.y = y;
                    this.hint.x = x;
                    this.hint.value = this.candidates[y][x][0];
                    return true;
                }
            }
        }
        return false;
    }

    /*
        根据棋盘数据进行初始化
    */
    init(grid) {
        this.hint = {
            y     : -1,
            x     : -1,
            value : -1,
        };
        this.candidates = [
            [ [], [], [], [], [], [], [], [], [] ],
            [ [], [], [], [], [], [], [], [], [] ],
            [ [], [], [], [], [], [], [], [], [] ],
            [ [], [], [], [], [], [], [], [], [] ],
            [ [], [], [], [], [], [], [], [], [] ],
            [ [], [], [], [], [], [], [], [], [] ],
            [ [], [], [], [], [], [], [], [], [] ],
            [ [], [], [], [], [], [], [], [], [] ],
            [ [], [], [], [], [], [], [], [], [] ]
        ];
        this.cellTrack = [
            [ [], [], [], [], [], [], [], [], [] ],
            [ [], [], [], [], [], [], [], [], [] ],
            [ [], [], [], [], [], [], [], [], [] ],
            [ [], [], [], [], [], [], [], [], [] ],
            [ [], [], [], [], [], [], [], [], [] ],
            [ [], [], [], [], [], [], [], [], [] ],
            [ [], [], [], [], [], [], [], [], [] ],
            [ [], [], [], [], [], [], [], [], [] ],
            [ [], [], [], [], [], [], [], [], [] ]
        ];
        this.strategyUnits = [];
        this.getCandates(grid);
    }

    /*
        工具函数
        根据棋盘数据得到所有单元格的候选值
    */
    getCandates(grid) {
        for (let y = 0; y < 9; y++) {
            for (let x = 0; x < 9; x++) {
                this.candidates[y][x] = this.getPosCandidates(y, x, grid);
            }
        }
    }

    getPosCandidates(y, x, grid) {
        const value = grid[y][x];

        let flags = [0,0,0,0,0,0,0,0,0];

        let ret = [];

        if (!value) {
            let unit = new StrategyUnit("Possible Number");

            for (let i = 0; i < 9; i++) {
                // Check the row
                if (i !== x && grid[y][i]) {
                    if (flags[grid[y][i] - 1] === 0) {
                        flags[grid[y][i] - 1] = 1;
                        unit.addCell(y, i, grid[y][i]);
                    }
                }

                // Check the column
                if (i !== y && grid[i][x]) {
                    if (flags[grid[i][x] - 1] === 0) {
                        flags[grid[i][x] - 1] = 1;
                        unit.addCell(i, x, grid[i][x]);
                    }
                }
            }

            // Check the box
            let box = getBox(y, x);
            let bs = new BoxScanner(0, 0, box);
            for (bs.begin(); !bs.end(); bs.next()) {
                if ((bs.y !== y || bs.x !== x) && grid[bs.y][bs.x]) {
                    if (flags[grid[bs.y][bs.x] - 1] === 0) {
                        flags[grid[bs.y][bs.x] - 1] = 1;
                        unit.addCell(bs.y, bs.x, grid[bs.y][bs.x]);
                    }
                }
            }

            for (let j = 0; j < 9; j++) {
                if (flags[j] === 0) {
                    ret.push(j+1);
                }
            }

            if (ret.length < 9) {
                this.strategyUnits.push(unit);
                this.cellTrack[y][x].push(this.strategyUnits.length - 1);
            }
        }
        return ret;
    }

    getHint() {
        return this.hint;
    }

    getInferenceGrid() {
        return this.candidates;
    }

    getCellTrack() {
        return this.cellTrack;
    }

    getStrategyUnits() {
        return this.strategyUnits;
    }

    getAnswer(grid) {
        if (this.hint.value === -1) {

            return {
                hasAnswer : false,
            }
        }
        else {

            let ret = {
                hasAnswer : true,
                y         : this.hint.y,
                x         : this.hint.x,
                value     : this.hint.value,
                highLight : [],  //StrategyCell list
                strategyLink : '',
                fullCandidates: [],
            };

            let len = this.cellTrack[this.hint.y][this.hint.x].length;

            let units = this.cellTrack[this.hint.y][this.hint.x];

            if (len === 0) {
                ret.strategyLink = "Possible Number";
            }
            else {

                for (let i = 0; i < len; i++) {
                    let strategyUnit = this.strategyUnits[units[i]];
                    if (i === len - 1 ) {
                        ret.strategyLink += strategyUnit.name();
                    }
                    else {
                        ret.strategyLink += strategyUnit.name() + ' -> ';
                    }

                    let cells = strategyUnit.getCells();

                    for (let j = 0; j < cells.length; j++) {
                        ret.highLight.push(cells[j]);
                        ret.fullCandidates.push(this.getPosCandidates(cells[j].y, cells[j].x, grid));
                    }
                }

                return ret;
            }

            return ret;
        }
    }
}

export const strategyManager = new StrategyManeger();
import { StrategyCell, StrategyUnit, StrategyOperator, Strategy } from '@sudoku/strategy/strategy_base';
import { SUDOKU_SIZE } from '@sudoku/constants';
import BoxScanner, {getBox, listToString} from '@sudoku/strategy/utils';

import { HSOperator } from '../operator/HSOp';

class HSStrategy extends Strategy {
    constructor() {
        super("Hidden Singles", new HSOperator(), [true, true, true]);
        // 记录所有行列宫中找到的HiddenSingles（只出现一次的候选值）
        this.hiddenSingles = new Map(); 
    }
    
    init () {
        // 开始前重置hiddenSingles，避免影响后续流程
        this.hiddenSingles = new Map(); 
    }

    load (midData) {
        // 将行列宫中找到的hiddenSingles收集起来
        for (let i = 0; i < midData.length; i++) {
            let single = midData[i];
            this.hiddenSingles.set(listToString(single.yx), single.value);
        }
    }

    handle (candidates, cellTrack, strategyUnits) {
        console.log("hidden singles", this.hiddenSingles);
        //返回需要高亮的单元格
        for (let [yx_str, value] of this.hiddenSingles) {
            // 搜索所有与hidden_single的相同数字，每个数字以Cell的形式存储在StrategyCell中
            // 该hidden_single的所有相同数字存储在StrategyUnit中
            let strategyUnit = new StrategyUnit("Hidden Singles");
            let yx_num = yx_str.split(' ').map(Number);
            for (let i = 0; i < SUDOKU_SIZE; i++) {
                for (let j = 0; j < SUDOKU_SIZE; j++) {
                    if (i !== yx_num[0] &&
                        j !== yx_num[1] && // 不是hidden single的单元格
                        candidates[i][j].length === 1 && 
                        candidates[i][j].includes(value)) {
                        strategyUnit.addCell(i, j, value);
                    }
                }
            }
            strategyUnits.push(strategyUnit);
            cellTrack[yx_num[0]][yx_num[1]].push(strategyUnits.length - 1);
        }
        // 是否缩小了候选值的范围
        let success = false;
        // 根据hidden_singles修改candidates,一旦修改表示缩小了候选值的范围
        for (let [yx_str, value] of this.hiddenSingles) {
            let yx_num = yx_str.split(' ').map(Number);
            let y = yx_num[0];
            let x = yx_num[1];
            candidates[y][x] = [value];
            success = true;
        }
        return success;
    }
}

export {
    HSStrategy
};
import { StrategyCell, StrategyUnit, StrategyOperator, Strategy } from '../strategy_base';

import BoxScanner, {getBox, listToString} from '../utils';

import { PairFindOperator } from '../operator/PairFindOp';

class NPStrategy extends Strategy
{
    constructor() {
        super("Naked Pairs", new PairFindOperator(), [true, true, true]);

        //对子字典
        this.findPairs = new Map();
    }

    //资源释放和初始化
    init() {
        this.findPairs = new Map();
    }

    load (midData) {
        for (let i = 0; i < midData.length; i++) {

            let key = listToString(midData[i]);
            if (!this.findPairs.has(key)) {
                this.findPairs.set(key, midData[i]);
            }

        }
    }

    handle (candidates, cellTrack, strategyUnits) {

        //判断是否有对子生效
        let pairUsed = false;

        const candidateHandle = (y, x, pair) => {

            if (candidates[y][x].length !== 0 && (y !== pair[2] || x !== pair[3]) && (y !== pair[0] || x !== pair[1]) ) {
                let index1 = candidates[y][x].indexOf(pair[4]);
                let index2 = candidates[y][x].indexOf(pair[5]);
    
                //判断对子是否会作用于该单元格
                if (index1 > -1 || index2 > -1) {

                    //记录策略对该单元格的影响
                    cellTrack[y][x].push(strategyUnits.length - 1);
    
                    pairUsed = true;

                    if (index1 > -1) {
                        candidates[y][x].splice(index1, 1);
                    }

                    index2 = candidates[y][x].indexOf(pair[5]);
                    if (index2 > -1) {
                        candidates[y][x].splice(index2, 1);
                    }
                }
            }
        }

        for (let [key, value] of this.findPairs) {

            let pair = value;

            let unit = new StrategyUnit(this.name());
    
            unit.addCell(pair[0], pair[1], [pair[4], pair[5]]);
            unit.addCell(pair[2], pair[3], [pair[4], pair[5]]);

            strategyUnits.push(unit);


            //如果是行对
            if (this.checkRowPairType(pair[0], pair[1], pair[2], pair[3])) {
                let y = pair[0];
    
                //遍历行
                for (let x = 0; x < 9; x++) {
                    candidateHandle(y, x, pair);
                }
            }
            if (this.checkColPairType(pair[0], pair[1], pair[2], pair[3])) {
                let x = pair[1];
    
                //遍历列
                for (let y = 0; y < 9; y++) {
                    candidateHandle(y, x, pair);
                }
            }
            if (this.checkBoxPairType(pair[0], pair[1], pair[2], pair[3])) {
    
                let box = getBox(pair[0], pair[1]);
    
                let bs = new BoxScanner(0, 0, box);
    
                for (bs.begin(); !bs.end(); bs.next()) {
                    candidateHandle(bs.y, bs.x, pair);
                }
            }
        }

        return pairUsed;
    }

    checkRowPairType(y1, x1, y2, x2) {
        return y1 === y2;
    }

    checkColPairType(y1, x1, y2, x2) {
        return x1 === x2;
    }

    checkBoxPairType(y1, x1, y2, x2) {
        return Math.floor(y1 / 3) === Math.floor(y2 / 3) && Math.floor(x1 / 3) === Math.floor(x2 / 3);
    }
}

export {
    NPStrategy
};
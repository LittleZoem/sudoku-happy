import { writable } from 'svelte/store';
import { SUDOKU_SIZE, BOX_SIZE} from '@sudoku/constants';
import { BoxScanner } from '@sudoku/utils.js';

class StrategyCell {
    constructor(y, x, values) {

        //需要高亮的候选值
        this.highLightValues = [];

        for (let i = 0; i < values.length; i++) {
            this.highLightValues.push(values[i]);
        }

        this.y = y;

        this.x = x;
    }

}

class StrategyUnit {
    constructor(name) {
        this.strategyName = name;

        this.cells = [];  // 类StrategyCell
    }

    addCell (y, x, values) {
        this.cells.push(new StrategyCell(y, x, values));
    }
}

class StrategyManeger
{
    /*
        grid : 当前棋盘的值
    */
    constructor() {

        // 得到的提示答案
        this.hint = {
            y     : -1,
            x     : -1,
            value : -1,
        };         
        this.candidates = [     // 所有单元格的候选值
            [ [], [], [], [], [], [], [], [], [] ],
            [ [], [], [], [], [], [], [], [], [] ],
            [ [], [], [], [], [], [], [], [], [] ],
            [ [], [], [], [], [], [], [], [], [] ],
            [ [], [], [], [], [], [], [], [], [] ],
            [ [], [], [], [], [], [], [], [], [] ],
            [ [], [], [], [], [], [], [], [], [] ],
            [ [], [], [], [], [], [], [], [], [] ],
            [ [], [], [], [], [], [], [], [], [] ]
        ];

        // 单元格候选值消除跟踪  StrategyUnit id数组
        this.cellTrack = [
            [ [], [], [], [], [], [], [], [], [] ],
            [ [], [], [], [], [], [], [], [], [] ],
            [ [], [], [], [], [], [], [], [], [] ],
            [ [], [], [], [], [], [], [], [], [] ],
            [ [], [], [], [], [], [], [], [], [] ],
            [ [], [], [], [], [], [], [], [], [] ],
            [ [], [], [], [], [], [], [], [], [] ],
            [ [], [], [], [], [], [], [], [], [] ],
            [ [], [], [], [], [], [], [], [], [] ]
        ];

        // 策略求解依据的单元格，需要高亮显示
        this.strategyUnits = []; 

        this.strategy = {       // 策略注册
            "HS" : HSMethod,
            "NP" : NPMethod,
        };

        this.strategyNames = {
            "HS" : "Hidden Singles",
            "NP" : "Naked Pairs",
        }
    }

    run(grid) {
        loadGrid(grid);

        let end = true;

        while (end) {
            end  = checkOnlyOne();

            if (!end) {
                break;
            }
    
            for (let key in this.strategy) {
                if (this.strategy.hasOwnProperty(key)) {
                    strategy[key](this.candidates, this.cellTrack, this.strategyUnits);
                }
            }
        }
    }

    checkOnlyOne () {
        for (let y = 0; y < 9; y++) {
            for (let x = 0; x < 9; x++) {
                if (this.candidates[y][x].length == 1) {
                    this.hint.y = y;
                    this.hint.x = x;
                    this.hint.value = this.candidates[y][x][0];
                    return false;
                }
            }
        }
        return true;
    }

    // 每次预测都要重新生成一边数据
    loadGrid(grid) {
        this.hint = {
            y     : -1,
            x     : -1,
            value : -1,
        }; 
        this.candidates = [
            [ [], [], [], [], [], [], [], [], [] ],
            [ [], [], [], [], [], [], [], [], [] ],
            [ [], [], [], [], [], [], [], [], [] ],
            [ [], [], [], [], [], [], [], [], [] ],
            [ [], [], [], [], [], [], [], [], [] ],
            [ [], [], [], [], [], [], [], [], [] ],
            [ [], [], [], [], [], [], [], [], [] ],
            [ [], [], [], [], [], [], [], [], [] ],
            [ [], [], [], [], [], [], [], [], [] ]
        ];
        this.cellTrack = [
            [ [], [], [], [], [], [], [], [], [] ],
            [ [], [], [], [], [], [], [], [], [] ],
            [ [], [], [], [], [], [], [], [], [] ],
            [ [], [], [], [], [], [], [], [], [] ],
            [ [], [], [], [], [], [], [], [], [] ],
            [ [], [], [], [], [], [], [], [], [] ],
            [ [], [], [], [], [], [], [], [], [] ],
            [ [], [], [], [], [], [], [], [], [] ],
            [ [], [], [], [], [], [], [], [], [] ]
        ];
        this.strategyUnits = [];
        getCandates(grid);
    }

    getCandates(grid) {
        for (let y = 0; y < SUDOKU_SIZE; y++) {
            for (let x = 0; x < SUDOKU_SIZE; x++) {
    
                const value = grid[y][x];

                let flags = [0,0,0,0,0,0,0,0,0];
    
                if (!value) {
                    for (let i = 0; i < SUDOKU_SIZE; i++) {
                        // Check the row
                        if (i !== x && grid[y][i]) {
                            flags[ grid[y][i] - 1 ] = 1;
                        }
    
                        // Check the column
                        if (i !== y && grid[i][x]) {
                            flags[ grid[i][x] - 1 ] = 1;
                        }
                    }
    
                    // Check the box
                    const startY = Math.floor(y / BOX_SIZE) * BOX_SIZE;
                    const endY = startY + BOX_SIZE;
                    const startX = Math.floor(x / BOX_SIZE) * BOX_SIZE;
                    const endX = startX + BOX_SIZE;
                    for (let row = startY; row < endY; row++) {
                        for (let col = startX; col < endX; col++) {
                            if (row !== y && col !== x && grid[row][col]) {
                                flags[ grid[row][col] - 1 ] = 1;
                            }
                        }
                    }
                }

                for (let j = 0; j < SUDOKU_SIZE; j++) {
                    if (flags[j] === 1) {
                        this.candidates[y][x].push(j+1);
                    }
                }
                
            }
        }
    }
}

export const strategyManeger = new StrategyManeger();

function HSMethod(candidates, cellTrack, strategyUnits) {
    // 对行列宫分别进行遍历，找出行、列、宫中只出现过一次的候选值

    // 记录可以通过hidden_singles策略确定的坐标以及值
    let hidden_singles = []

    // 对行遍历
    for (let i = 0; i < SUDOKU_SIZE; i++) {
        // 统计一行中候选值里各个数字（1-9）出现的次数
        let num_count = [0, 0, 0, 0, 0, 0, 0, 0, 0];
        for (let j = 0; j < SUDOKU_SIZE; j++) {
            for (let value of candidates[i][j]) {
                num_count[value - 1]++;
            }
        }
        // 找出只出现了一次的数字
        let singles = []
        for (let k = 0; k < num_count.length; k++) {
            if (num_count === 1)
                singles.push(k + 1);
        }
        // 根据singles（只出现了一次的数字），找到能确定的单元格
        for (let j = 0; j < SUDOKU_SIZE; j++) {
            for (let k = 0; k < candidates[i][j].length; k++) {
                // 如果包括在singles中，说明在该行中这个数字只出现了一次，那么这个值可以唯一确定
                // 存储这个单元格的内容在hidden_singles里
                if (singles.includes(candidates[i][j][k])) {
                    hidden_singles.push({
                        y: i,
                        x: j,
                        value: candidates[i][j][k],
                    });
                }
            }
        }
    }

    // 对列遍历
    for (let i = 0; i < SUDOKU_SIZE; i++) {
        // 统计一列中候选值里各个数字（1-9）出现的次数
        let num_count = [0, 0, 0, 0, 0, 0, 0, 0, 0];
        for (let j = 0; j < SUDOKU_SIZE; j++) {
            for (let value of candidates[j][i]) {
                num_count[value - 1]++;
            }
        }
        // 找出只出现了一次的数字
        let singles = []
        for (let k = 0; k < num_count.length; k++) {
            if (num_count === 1)
                singles.push(k + 1);
        }
        // 根据singles（只出现了一次的数字），找到能确定的单元格
        for (let j = 0; j < SUDOKU_SIZE; j++) {
            for (let k = 0; k < candidates[j][i].length; k++) {
                // 如果包括在singles中，说明在该列中这个数字只出现了一次，那么这个值可以唯一确定
                // 存储这个单元格的内容在hidden_singles里
                if (singles.includes(candidates[j][i][k])) {
                    hidden_singles.push({
                        y: i,
                        x: j,
                        value: candidates[j][i][k],
                    });
                }
            }
        }
    }

    // 对宫遍历
    for (let i = 0; i < BOX_SIZE; i++) {
        for (let j = 0; j < BOX_SIZE; j++) {
            // 统计一个宫中候选值里各个数字（1-9）出现的次数
            let num_count = [0, 0, 0, 0, 0, 0, 0, 0, 0];
            let boxScanner = new BoxScanner(i * 3, j * 3);
            for (boxScanner.begin(); !boxScanner.end(); boxScanner.next()) {
                for (let value of candidates[boxScanner.y][boxScanner.x]) {
                    num_count[value - 1]++;
                }
            }

            // 找出只出现了一次的数字
            let singles = []
            for (let k = 0; k < num_count.length; k++) {
                if (num_count === 1)
                    singles.push(k + 1);
            }

            // 根据singles（只出现了一次的数字），找到能确定的单元格
            for (boxScanner.begin(); !boxScanner.end(); boxScanner.next()) {
                for (let k = 0; k < candidates[j][i].length; k++) {
                    // 如果包括在singles中，说明在该宫中这个数字只出现了一次，那么这个值可以唯一确定
                    // 存储这个单元格的内容在hidden_singles里
                    if (singles.includes(candidates[boxScanner.y][boxScanner.x][k])) {
                        hidden_singles.push({
                            y: boxScanner.y,
                            x: boxScanner.x,
                            value: candidates[boxScanner.y][boxScanner.x][k],
                        });
                    }
                }
            }
        }
    }

    // 返回需要高亮的单元格
    // hidden_single要高亮所有相同的数字
    su = new StrategyUnit("Hidden Singles");
    for (let single of hidden_singles) {
        // 搜索所有与hidden_single的相同数字
        for (let i = 0; i < SUDOKU_SIZE; i++) {
            for (let j = 0; j < SUDOKU_SIZE; j++) {
                if (candidates[i][j].length === 1 && candidates[i][j].includes(single.value)) {
                    su.addCell(i, j, single.value);
                }
            }
        }
    }
    strategyUnits.push(su);
    
    // 根据hidden_singles修改candidates，记录删除的候选值
    for (let single of hidden_singles) {
        cellTrack[single.y][single.x] = candidates[single.y][single.x].filter(value => value !== single.value);
        candidates[single.y][single.x] = [single.value];
    }

    return ;
}

function NPMethod(candidates) {

    // let ret = {
    //     answer: [],  // y x val
    //     highLight: [], //y1 x1, y2 x2
    // };

    // let findPairs = []; // y1 x1 y2 x2 val1 val2 type
    //                     // type: 0行对 1列对 2宫格对

    // let globalRemoveTrack = [
    //     [ [], [], [], [], [], [], [], [], [] ],
    //     [ [], [], [], [], [], [], [], [], [] ],
    //     [ [], [], [], [], [], [], [], [], [] ],
    //     [ [], [], [], [], [], [], [], [], [] ],
    //     [ [], [], [], [], [], [], [], [], [] ],
    //     [ [], [], [], [], [], [], [], [], [] ],
    //     [ [], [], [], [], [], [], [], [], [] ],
    //     [ [], [], [], [], [], [], [], [], [] ],
    //     [ [], [], [], [], [], [], [], [], [] ],
    // ]  // 对子索引

    // //每一行遍历，在每一行检查对子
    // for (let y = 0; y < SUDOKU_SIZE; y++) {

    //     let findPair = []; // x1 x2 val1 val2

    //     //遍历行中每一个空位，如果有只有两个候选值的空，则去寻找是否有其他一样的空能形成对子
    //     for (let x = 0; x < SUDOKU_SIZE - 1; x++) {

    //         if (hideCandidates[y][x].length == 2) {
    //             for (let i = x + 1; i < SUDOKU_SIZE; i++) {
    //                 if (hideCandidates[y][i].length == 2 && hideCandidates[y][i][0] === hideCandidates[y][x][0] && hideCandidates[y][i][1] === hideCandidates[y][x][1]) {
    //                     findPairs.push([y, x, y, i, hideCandidates[y][x][0], hideCandidates[y][x][1], 0]);
    //                 }
    //             }
    //         }
    //     }
    // }

    
    // //每一列遍历，在每一行检查对子
    // for (let x = 0; x < SUDOKU_SIZE; x++) {

    //     let findPair = []; // x1 x2 val1 val2

    //     //遍历行中每一个空位，如果有只有两个候选值的空，则去寻找是否有其他一样的空能形成对子
    //     for (let y = 0; y < SUDOKU_SIZE - 1; y++) {

    //         if (hideCandidates[y][x].length == 2) {
    //             for (let i = y + 1; i < SUDOKU_SIZE; i++) {
    //                 if (hideCandidates[i][x].length == 2 && hideCandidates[i][x][0] === hideCandidates[y][x][0] && hideCandidates[i][x][1] === hideCandidates[y][x][1]) {
    //                     findPairs.push([y, x, i, x, hideCandidates[y][x][0], hideCandidates[y][x][1], 0]);
    //                 }
    //             }
    //         }
    //     }
    // }

    // const startY = Math.floor(y / BOX_SIZE) * BOX_SIZE;
    // const endY = startY + BOX_SIZE;
    // const startX = Math.floor(x / BOX_SIZE) * BOX_SIZE;
    // const endX = startX + BOX_SIZE;
    // for (let y = startY; y < endY; y++) {
    //     for (let x = startX; x < endX; x++) {
    //         if (hideCandidates[y][x].length == 2) {
                
    //         }
    //     }
    // }


    return 
}